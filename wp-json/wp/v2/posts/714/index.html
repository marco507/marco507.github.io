{"id":714,"date":"2023-12-15T19:18:30","date_gmt":"2023-12-15T18:18:30","guid":{"rendered":"http:\/\/192.168.178.139\/?p=714"},"modified":"2023-12-16T19:31:09","modified_gmt":"2023-12-16T18:31:09","slug":"analysing-website-technologies-a-complete-data-science-project","status":"publish","type":"post","link":"http:\/\/192.168.178.139\/analysing-website-technologies-a-complete-data-science-project\/","title":{"rendered":"Analysing Website Technologies &#8211; A Complete Data Science Project"},"content":{"rendered":"<p>As the digital landscape continues to evolve at a rapid pace, understanding the technologies that power websites has become increasingly crucial. From front-end frameworks to server-side languages, the array of tools and platforms available can be overwhelming for businesses and developers alike. In this data science project, we will do an analysis of website technologies to uncover insights that can inform strategic decision-making in the ever-changing world of web development. The benefits of such an analysis could be for example a database of possible business leads or having a basis for a data-driven hiring strategy.<\/p>\n<p>The scope of this project ranges across the whole data science workflow, from raw data acquisition to reporting of the results. The list below highlights the individual milestones of the project, which we will discuss in detail later on:<\/p>\n<ol>\n<li>Compiling a reasonably sized dataset of website links with the corresponding industry branch and the technologies used to run the web presence<\/li>\n<li>Wrangling the data into an accessible format that can be used for further analysis<\/li>\n<li>Creation of an interactive web-based report featuring self-service analytics that can be used by decision makers<\/li>\n<\/ol>\n<h2>Gathering the dataset<\/h2>\n<p>If you ask data professionals about their favorite task, the answer will most certainly be scraping of unstructured web data, which can be considered the modern equivalent of working in a 19th century coal mine. Of course, web scraping was also the starting point for this project, with our first contact point being a well-known public database of Austrian companies. The idea here was to leverage their already existing categorization of websites into industry branches, which we can use for example to spot possible differences in technology choice. Maybe a web agency is specifically targeting retail businesses and want to exactly know their prevalent technology choices. By using the categories, we can add another layer of granularity to our dataset and answer such questions.<\/p>\n<p>Gathering the data is done with a Python script that utilizes several libraries, including requests, BeautifulSoup, Wappalyzer, and fire. It uses the requests library to make an HTTP GET request and checks the status code of the response. If the status code is 200, indicating a successful request, the HTML content is returned. If the status code is 404, the script prints a message and skips the site. For status codes 400 and 500, the script continues the loop to retry the request. This method ensures that the script handles different scenarios when fetching web pages.<\/p>\n<p>Overall, the script is designed to scrape multiple pages of each industry branch from the company database until a threshold of 1000 websites including technology stacks are gathered for each branch. The method iterates over the pagination, gets the URL for each company profile, and fetches the HTML content like discussed above. It then uses BeautifulSoup to parse the HTML and extract the actual website link for a company from the profile page. If a website link is found, the script uses the Wappalyzer library to analyze the technology stack of the website. The results are then written to a CSV file.<\/p>\n<p>We always check if the actual website link returns a 200 status code so that we do not scrape broken links. Additionally, the fire library is employed to create a command-line interface for the script to allow running multiple instances of the script in tandem. Theoretically, we could use multiple threads, but having a dedicated terminal and status bar makes the whole process more manageable. To facilitate comprehension, I included a diagram of the scraping process, which can be seen <a href=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-scraping_flow.jpg\" target=\"_blank\" rel=\"noopener\">here<\/a>.<\/p>\n<h2>Wrangling and database creation<\/h2>\n<p>At the end of the data acquisition, we now have ten different CSV files (one for each branch), with each one containing 1000 websites and their technologies. The next steps of the project are concerned with bringing the raw data into a suitable format for the final analysis and visualization. First we load each of the ten CSV files and convert them into a single Pandas DataFrame which looks as following:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-729 aligncenter\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack-analysis_dataframe.png\" alt=\"\" width=\"690\" height=\"200\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack-analysis_dataframe.png 690w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack-analysis_dataframe-300x87.png 300w\" sizes=\"(max-width: 690px) 100vw, 690px\" \/><\/p>\n<p>If we examine the &#8220;Techstack&#8221; column, we can see dictionaries containing the technologies. These dictionaries are thereby stored as strings. Now we have multiple possibilities to format our data, for example we could split our dictionaries and store each link, branch and technology combination as a distinct record in the DataFrame. Considering that we will also enrich our data with additional categories for the technologies and that a technology can have multiple categories, we quickly get a lot of redundant data to store. If we flatten out all possible combination, we blow up our DataFrame from 10000 to around 60000 records.<\/p>\n<p>This would not be an issue for this small dataset, but if we want to incrementally add new data in the future, this would lead to issues at some point in time. To alleviate this problem, we will create a dedicated SQL database in third normal form to minimize the storage of redundant data. This database will then serve as the basis for our analysis and the web-based report. The ER-diagram below describes the schema that we will implement:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-730 aligncenter\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-er_diagram.jpg\" alt=\"\" width=\"490\" height=\"401\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-er_diagram.jpg 490w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-er_diagram-300x246.jpg 300w\" sizes=\"(max-width: 490px) 100vw, 490px\" \/><\/p>\n<p>We create the database with the Sqlite3 library starting by creating a schema and following we fill the &#8220;Website&#8221;, &#8220;Technology&#8221; and &#8220;Category&#8221; table. The next step is also relatively straightforward, where we use loops and checks to fill up the so-called join tables named &#8220;Website_Technology&#8221; and &#8220;Technology_Category&#8221;. If you ask why the schema is set up in this form, consider the following example: A website has jQuery, WordPress and PHP in their technology stack. Regarding the categories of each technology, we have &#8220;JavaScript&#8221; library for jQuery, &#8220;Programming Language&#8221; for PHP and for WordPress we have two categories, namely &#8220;Blog&#8221; and &#8220;CMS&#8221; (Content Management System).<\/p>\n<p>Now instead of creating an individual record for each possible combination, we just fill the &#8220;Website&#8221;, &#8220;Technology&#8221; and &#8220;Category&#8221; table with the respective entities and then create an entry for each relation in the join tables. So going back to our example, we would create three entries in the &#8220;Website_Technology&#8221; table, with all entries pointing at the website and each entry pointing at one of the technologies. Now we do the same for the &#8220;Technology_Category&#8221; table, and we can effectively reduce redundant data storage to a minimum. Additionally, we get the convenience of using SQL for our analysis in the next step<\/p>\n<h2>Deploying the Report<\/h2>\n<p>To follow suit with current state-of-the-art solutions for data visualization like Power BI or Tableau, we will create an interactive report with some basic self-service analytics. To do this, we use the Streamlit framework, which is optimized for fast development of data-apps with Python. The architecture of the web application is thereby relatively straightforward, because we basically connect standard front-end components like sliders, drop down menus and forms with SQL commands that interface with the database. With the additional integration of plotting capabilities in Streamlit, we can then build very neat data dashboards in a reasonable time. A quick overview of the architecture can be seen below:<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"size-full wp-image-736 aligncenter\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-web_app.jpg\" alt=\"\" width=\"511\" height=\"116\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-web_app.jpg 511w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/12\/techstack_analysis-web_app-300x68.jpg 300w\" sizes=\"(max-width: 511px) 100vw, 511px\" \/><\/p>\n<p>Now there is not much left to say about the web app except that it can be viewed with the following link, so please take a look for yourself. -&gt; <a href=\"https:\/\/techstack-analysis.streamlit.app\/\">Techstack Analysis Report<\/a><\/p>\n<h2>Conclusion<\/h2>\n<p>In this article, we looked at a project that encompassed the whole data science workflow, from gathering raw data to the creation of an interactive report that could be used by decision makers to guide their strategies. Such a project features a lot of different technologies and techniques that must be orchestrated to deliver a usable final result. Nonetheless, this usage of different tools for creative problem-solving, is probably the most exciting part of data science. As always, the code for this project can be found on GitHub in the following <a href=\"https:\/\/github.com\/marco507\/Techstack-Analysis-Report\" target=\"_blank\" rel=\"noopener\">repository<\/a>.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>As the digital landscape continues to evolve at a rapid pace, understanding the technologies that power websites has become increasingly crucial. From front-end frameworks to [&#8230;]<\/p>\n","protected":false},"author":2,"featured_media":744,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[10,1,5],"tags":[],"_links":{"self":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/714"}],"collection":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/comments?post=714"}],"version-history":[{"count":23,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/714\/revisions"}],"predecessor-version":[{"id":745,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/714\/revisions\/745"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media\/744"}],"wp:attachment":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media?parent=714"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/categories?post=714"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/tags?post=714"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}