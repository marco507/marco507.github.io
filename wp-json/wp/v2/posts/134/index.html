{"id":134,"date":"2023-07-09T16:17:32","date_gmt":"2023-07-09T14:17:32","guid":{"rendered":"http:\/\/192.168.178.139\/?p=134"},"modified":"2023-07-10T11:12:47","modified_gmt":"2023-07-10T09:12:47","slug":"developing-a-habit-tracker","status":"publish","type":"post","link":"http:\/\/192.168.178.139\/developing-a-habit-tracker\/","title":{"rendered":"Developing a Habit Tracker"},"content":{"rendered":"<p>Developing positive habits and eliminating negative ones can be a challenging endeavor. We all strive to maintain consistency in our actions and achieve personal goals, but it&#8217;s not always easy to stay on track. Thankfully, the growing trend of habit trackers has emerged as a valuable tool to support individuals in their pursuit of self-improvement. With a quick visit to any popular app store, you&#8217;ll discover a vast array of habit-tracking applications available, catering to various needs and preferences. Nonetheless, in my quest to enhance my programming skills, I have decided to create my own habit-tracking application in Python as one of my first serious attempts at development.<\/p>\n<p>Formally, a habit refers to a clearly defined task that requires periodic completion, such as daily teeth brushing or annual dentist visits. The fundamental components of a habit-tracking app can be outlined as follows:<\/p>\n<ul>\n<li>The application allows users to define multiple habits, each with its own task specification and periodicity.<\/li>\n<li>Users have the ability to mark tasks as completed, indicating that they have been checked off at any given time.<\/li>\n<li>Each habit necessitates at least one task completion within the user-defined period. Failure to complete a habit during the specified period is considered breaking the habit.<\/li>\n<li>If a user successfully completes a habit for a consecutive number of periods without any breaks, it is referred to as establishing a streak. For example, if a user works out every day for two full weeks, they would have a 14-day streak of exercising.<\/li>\n<li>The app not only stores the habits entered by users but also provides analysis features. Users can obtain insights into various aspects, such as determining their longest habit streak or accessing a list of their current daily habits.<\/li>\n<\/ul>\n<h2>Conception<\/h2>\n<p>The most important part of any project is the conception phase because anything that is overlooked or forgotten in this phase has a negative effect on the implementation later and might lead to a failed project. So the first step of this project was to describe everything that was necessary to build the app and put it into a written concept. Following we will talk about the general idea for the program flow, the database schema, an overview of the different components, and how they interact with each other.<\/p>\n<h3>Program Flow<\/h3>\n<p>I decided to design my application similar to classic UNIX command line tools (e.g. ls, grep). This means, that the functionality of the application can be utilized directly from the command line by issuing parameters with the application call. So the application is started up, executes the given command, and terminates after every user interaction.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-138 size-full\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_program-flow.jpg\" alt=\"\" width=\"542\" height=\"242\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_program-flow.jpg 542w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_program-flow-300x134.jpg 300w\" sizes=\"(max-width: 542px) 100vw, 542px\" \/><\/p>\n<h4>Data Storage<\/h4>\n<p>For persistent data storage, we will use Python\u2019s built-in sqlite3 library which allows us to setup a lightweight SQL database stored in a single file. This database file acts as the backbone of the application, with all functionality reading and writing from and to the database. The idea here is to embed SQL code, which allows precise manipulation and querying of the habit data, into the methods and functions written in Python. With this approach, we have full access to powerful SQL queries inside our application.<\/p>\n<p>The data around a habit is stored in two different tables. The first table holds the data concerning a habit in general and the second table stores the tracking data of a habit, which means that every time a habit is checked-off, the current date is stored as an entry. Additionally, the database sports a periods table containing the supported periods (Daily, Weekly) and a user table for handling login\/logout functionality.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-198\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_database.jpg\" alt=\"\" width=\"541\" height=\"421\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_database.jpg 541w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_database-300x233.jpg 300w\" sizes=\"(max-width: 541px) 100vw, 541px\" \/><\/p>\n<p>&nbsp;<\/p>\n<h4>Habit Management, Analytics, and CLI<\/h4>\n<p>We will store all the logic necessary for creating, deleting, and checking habits, in a class called Habit. The class consists of three methods, create, delete, and check that contain the respective SQL and Python logic. Upon success or failure of a command, a message is printed back to the command line.<\/p>\n<p>For analyzing the habits we will create a separate module containing all necessary functions which will adhere to a functional programming paradigm to avoid side effects and changing the stored data. For implementing the control of the application with command line parameters, the Fire library is used. Fire utilizes a function that takes a module, object, class, or another function as an argument and exposes it to the command line.<\/p>\n<p>To finally bring all the components together, the class Habit and the module containing the analytics functions are assigned to the class Pipeline. The Pipeline class effectively wraps all functionality, is then passed to the aforementioned function of the Fire module and an instance of the class is called in the main Python script.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-199\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_classes.jpg\" alt=\"\" width=\"541\" height=\"373\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_classes.jpg 541w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_classes-300x207.jpg 300w\" sizes=\"(max-width: 541px) 100vw, 541px\" \/><\/p>\n<p>&nbsp;<\/p>\n<h2>Development<\/h2>\n<p>After discussing the concept that was used as a basis for development, we will now look at the actual implementation in greater detail. We will start off with an overview of the application structure and look into the individual components later on.<\/p>\n<h3>Application components<\/h3>\n<p>The application is split into 8 different files:<\/p>\n<ul>\n<li><strong>habits.py<\/strong>\n<ul>\n<li>Contains the class for creating, deleting, and checking habits and for exposing functionality to the command line.<\/li>\n<\/ul>\n<\/li>\n<li><strong>analytics.py<\/strong>\n<ul>\n<li>Contains all functions for analyzing habits<\/li>\n<\/ul>\n<\/li>\n<li><strong>pipeline.py<\/strong>\n<ul>\n<li>Contains a class for wrapping all functionality for the CLI<\/li>\n<\/ul>\n<\/li>\n<li><strong>admin.py<\/strong>\n<ul>\n<li>Functions for initializing or deleting the database and generating random data entries<\/li>\n<\/ul>\n<\/li>\n<li><strong>user.py<\/strong>\n<ul>\n<li>Functions for login, logout, and echoing the current user<\/li>\n<\/ul>\n<\/li>\n<li><strong>tracker.py<\/strong>\n<ul>\n<li>The main file that exposes all functionality to the command line<\/li>\n<\/ul>\n<\/li>\n<li><strong>decorators.py<\/strong>\n<ul>\n<li>Contains all decorators<\/li>\n<\/ul>\n<\/li>\n<li><strong>test_tracker.py<\/strong>\n<ul>\n<li>Contains the unit test suite<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<h4>tracker.py<\/h4>\n<p>The tracker.py file contains the main entry for regular program usage concerning management and analyzing habits. This is done by importing the Pipeline class which is then passed to the Fire library in the main loop. The main loop essentially consists of two checks, first if the database is initialized and second, if a user is logged in. After the successful completion of the two checks, Fire&#8217;s functionality is called with the user&#8217;s argument, effectively executing whatever action the user wants.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-165\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_tracker-py.jpg\" alt=\"\" width=\"281\" height=\"391\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_tracker-py.jpg 281w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_tracker-py-216x300.jpg 216w\" sizes=\"(max-width: 281px) 100vw, 281px\" \/><\/p>\n<h3>habits.py<\/h3>\n<p>The habits.py file contains the Habit class, which supports the three methods create, delete and check. The method names are as concise as possible to avoid complicated commands on the user side. When a new instance of the Habit class is created through Fire, the constructor establishes a database connection and assigns it as an attribute to the new instance. With this, the database connection is then available to all three methods. Additionally, the username of the actual user is also assigned as a class attribute.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-191\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_habits-py.jpg\" alt=\"\" width=\"239\" height=\"204\" \/><\/p>\n<h5>Creating and Deleting a Habit<\/h5>\n<p>The create method takes the habits name and period as input from the user and a third argument entry_date which is at default today&#8217;s date. The date always defaults to the actual date with the __filter_date function if a user is logged in, so this argument is purely for the test data generator and the unit test to allow custom dates. The methods flow is first a call to the __filter_date function, second, a check if the period value is correct (Daily, Weekly), third a check if the habit does not already exist, and then an INSERT statement with the username and today&#8217;s date.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-170\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_create.jpg\" alt=\"\" width=\"441\" height=\"521\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_create.jpg 441w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_create-254x300.jpg 254w\" sizes=\"(max-width: 441px) 100vw, 441px\" \/><\/p>\n<p>The delete method only takes the habit&#8217;s name as an argument. First, the method checks if the habit exists, followed by a DELETE statement.<\/p>\n<h5>Checking a Habit<\/h5>\n<p>The check method takes the habit&#8217;s name and date as an argument. As for the create method, the date is defaulted to today if a real user is logged in. The check method first checks if the given habit exists in the database, then evaluates if the habit is already checked for today. Then the method queries the given habits ID, followed by the period, and the last date on which the habit has been checked.<\/p>\n<p>Following, the method evaluates if the habit is checked for the first time. If this is the first check, the streak is increased, else it must be evaluated if the streak is broken. If the period is daily, the last check date must be yesterday, else the streak is broken. If the period is weekly, the last check date must be at a maximum, seven days from today, or else the streak is broken. If the streak is broken the breaks must be incremented.<\/p>\n<p>Then it must be checked if the current streak is also the longest streak. To evaluate this the method queries the LongestStreak entry and if the CurrentStreak is greater than the LongestStreak the value is increased. Lastly, a new entry in the tracking data table is inserted.<\/p>\n<h3><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-173\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_check.jpg\" alt=\"\" width=\"818\" height=\"1018\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_check.jpg 818w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_check-241x300.jpg 241w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_check-768x956.jpg 768w\" sizes=\"(max-width: 818px) 100vw, 818px\" \/><\/h3>\n<h3>analytics.py<\/h3>\n<p>The analytics.py file contains the functions for analyzing habits and helper functions for establishing a database connection. The functions for normal program usage are combined in the class Analytics which is done solely for combining all functions in a single namespace. All functions are decorated with @staticmethod which allows calling the functions without initializing a class instance, keeping the function as pure as possible.<\/p>\n<p>The functions were implemented with the help of a lot of list and dictionary comprehensions to avoid value assignments. The more complex functions are implemented by nesting functions and the usage of higher-order functions. Lastly, the functions are decorated with the @user_message decorator, which is a self-coded decorator that returns a message to the user if the function returns no data. With this decorator, we can avoid print statements in the functions.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-175\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_analytics-py.jpg\" alt=\"\" width=\"511\" height=\"232\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_analytics-py.jpg 511w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_analytics-py-300x136.jpg 300w\" sizes=\"(max-width: 511px) 100vw, 511px\" \/><\/p>\n<h3>pipeline.py<\/h3>\n<p>This file basically imports the Habit and Analytics classes and wraps the functionality of the two with the class Pipeline.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-195\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_pipeline-py.jpg\" alt=\"\" width=\"239\" height=\"74\" \/><\/p>\n<h3>admin.py<\/h3>\n<p>The admin.py\u00a0 file contains the functionality to initialize or reset the database, both for regular usage and by the unit test suite to set up a test environment. Additionally, we have a function for generating test data.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-177\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_database.jpg\" alt=\"\" width=\"239\" height=\"126\" \/><\/p>\n<h5>Creating and Deleting a Database<\/h5>\n<p>The initialize function establishes a database connection and then executes two CREATE TABLE statements. This creates the database.db file with the two tables habits and trackingdata. If a database already existed, the sqlite3 library returns an error, which is captured in an except block, and an error message is returned.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-178\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_initalize.jpg\" alt=\"\" width=\"281\" height=\"392\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_initalize.jpg 281w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_initalize-215x300.jpg 215w\" sizes=\"(max-width: 281px) 100vw, 281px\" \/><\/p>\n<p>The second function, delete, first checks if a database file exists and then deletes it.<\/p>\n<h5>Generating Testdata<\/h5>\n<p>The third function testdata uses the Habit classes check method with randomly generated entry dates for a predefined dictionary filled with habits.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-180\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_testdata.jpg\" alt=\"\" width=\"483\" height=\"1123\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_testdata.jpg 483w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_testdata-129x300.jpg 129w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_setup-py_testdata-440x1024.jpg 440w\" sizes=\"(max-width: 483px) 100vw, 483px\" \/><\/p>\n<h3>user.py<\/h3>\n<p>The user.py is used for all functions related to user management. The file contains a class User for wrapping the functions login, logout, and whoami, all decorated with @staticmethod. The first function, login takes a username as an argument and then writes it into the user table of the database.<\/p>\n<p>The second function whoami is used to return the current user from the database. This function is also used by various other functions to get the actual username.<\/p>\n<p>The third function logout, first checks if a user is logged in at the moment and then sets the user&#8217;s status to logged out in the user table.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-181\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_login-py.jpg\" alt=\"\" width=\"239\" height=\"126\" \/><\/p>\n<h3>decorators.py<\/h3>\n<p>The decoratos.py contains all decorators. The habit tracker contains two scenarios, where decorators are good alternatives to helper functions. First for the functions of the analytics.py and second for the unit test suite.\u00a0 The first decorator @user_message is used to return a message to the user when an analytics function returns an empty dataset. Although not necessary, the user gets a simple message &#8220;No data&#8221; instead of an empty prompt if a function returns nothing. The core of the user_message decorator is thereby a conditional expression inside a try\/except block. The called analytics function is checked with the any function. If the function returns an empty list the conditional expression evaluates to False and the message No Data is returned, else the functions return value is printed.<\/p>\n<p>The second decorator @capture_print captures print statements for the unit test to evaluate. The function first checks if the username is testuser and then redirects the standard output to a variable. After capturing the value of the print statement in the variable, the standard output is then reset to normal.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-182\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_decorator-py.jpg\" alt=\"\" width=\"249\" height=\"151\" \/><\/p>\n<h3>test_tracker.py<\/h3>\n<p>The last component of the habit tracker is the unit test suite contained in test_tracker.py. The unit test suite was implemented with the unittest library included in Python. The test_tracker.py consists of two classes, TestHabit and TestAnalytics, which are then combined in one test suite. Both classes first construct a test environment in the form of a default database. After the set-up, the test for the various methods and functions is executed. After testing the functionality, the test database is deleted and the previous database, if it existed, is restored. Both classes make use of the various assert functions of the unittest library, to evaluate the results of queries or the return values of functions.<\/p>\n<p>For testing the methods of Habit, data is first inserted, deleted, or checked via the respective methods and then the database entries are queried by a separate function. This query result is then compared against predefined data to ensure the methods work as expected. For testing the analytics functions, the test database is filled with predefined data, which is then analyzed. The return values are then compared against the expected values.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-183\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/habit-tracker_test-py.jpg\" alt=\"\" width=\"239\" height=\"243\" \/><\/p>\n<h2>Conclusion<\/h2>\n<p>Looking back on the creation of the habit tracker, I can say that this project was a very pleasant and rewarding learning experience. The project definitely improved my programming skills by a<br \/>\nwide margin in regard to object-oriented and functional programming. Personally, I am satisfied with the final product&#8217;s functionality and the UNIX-tool-like control. The code for the habit tracker can be found in the following <a href=\"https:\/\/github.com\/marco507\/Habit-Tracking-Application\">GitHub repo<\/a>.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Developing positive habits and eliminating negative ones can be a challenging endeavor. We all strive to maintain consistency in our actions and achieve personal goals, [&#8230;]<\/p>\n","protected":false},"author":2,"featured_media":205,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[6,1],"tags":[],"_links":{"self":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/134"}],"collection":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/comments?post=134"}],"version-history":[{"count":10,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/134\/revisions"}],"predecessor-version":[{"id":213,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/134\/revisions\/213"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media\/205"}],"wp:attachment":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media?parent=134"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/categories?post=134"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/tags?post=134"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}