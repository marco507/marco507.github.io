{"id":238,"date":"2023-07-10T13:46:36","date_gmt":"2023-07-10T11:46:36","guid":{"rendered":"http:\/\/192.168.178.139\/?p=238"},"modified":"2023-07-18T17:33:38","modified_gmt":"2023-07-18T15:33:38","slug":"anomaly-detection-in-a-factory-setting","status":"publish","type":"post","link":"http:\/\/192.168.178.139\/anomaly-detection-in-a-factory-setting\/","title":{"rendered":"Anomaly Detection in a Factory Setting"},"content":{"rendered":"<p>While working at my current workplace, the opportunity arose to design a proof-of-concept for a system that effectively identifies potential anomalies within the production cycle. By leveraging the expertise of the shop floor employees and utilizing machine learning techniques, the objective was to create a system that seamlessly integrates with the existing factory infrastructure.<\/p>\n<p>The factory specializes in the manufacturing of staircases and there was a desire to implement a decision support system that proactively alerts our CNC operators regarding issues with their current workpiece. In my role as an aspiring data scientist, I was more than happy to address this need by developing an anomaly detection system that enhances the factory&#8217;s operational efficiency.<\/p>\n<p>In collaboration with the experienced shop floor employees, who possess domain knowledge accumulated over their extensive tenure at the production site, we identified key indicators of anomalies: temperature, humidity, and sound volume. These factors were determined to be reliable indicators of potential anomalies within the production cycle, including the presence of faulty items.<\/p>\n<p>By proactively identifying potential issues within the production cycle, the system would enable timely interventions, leading to enhanced productivity, reduced downtime, and improved product quality. In the subsequent sections of this project report will delve into the details of the approach, methodology, and specific techniques employed to develop and implement the anomaly detection system.<\/p>\n<h2>System Overview<\/h2>\n<p>We will, first of all, discuss the general implementation procedure of the project and how the components of the whole system fit together. So, the overall anomaly detection package consists of two working parts. The first component is a Python script that contains a class for simulating the generation of three distinct sensor readings, as there were no sensors mounted during the development of this proof-of-concept. The virtual sensor readings are temperature, humidity, and volume which are generated at a frequency of two hertz and are sent via HTTP requests.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-244\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_system-overview.jpg\" alt=\"\" width=\"499\" height=\"204\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_system-overview.jpg 937w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_system-overview-300x123.jpg 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_system-overview-768x314.jpg 768w\" sizes=\"(max-width: 499px) 100vw, 499px\" \/><\/p>\n<p>On the receiving end and as the second component we have a web application based on Django. The web application features a REST-API endpoint for receiving the virtual sensor data, a machine learning model for predicting anomalies, an administration interface for authenticating simulated machines, and a SQL database for storing logged data.<\/p>\n<h2>Implementation Procedure<\/h2>\n<p>In the case of this project, the first step was centered around the core of the whole system, which is the machine learning model. To get a working model it was necessary to research the necessary techniques for the anomaly detection use case. Thereby the model was first trained with self-generated data and then serialized for later usage in the web application.<\/p>\n<p>After the creation of a usable model, the first version of the web application was developed. This first version included the API endpoint for receiving data and the administration interface for registering machines. To complement the web application, the next step was to write the script for generating sensor data.<\/p>\n<p>In the final step, the web application was then finished by complementing the data logging functionality and migrated to the cloud.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-248\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_implementation_procedure.jpg\" alt=\"\" width=\"650\" height=\"262\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_implementation_procedure.jpg 1130w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_implementation_procedure-300x121.jpg 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_implementation_procedure-1024x412.jpg 1024w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_implementation_procedure-768x309.jpg 768w\" sizes=\"(max-width: 650px) 100vw, 650px\" \/><\/p>\n<h2>Training Data Characteristics<\/h2>\n<p>An anomaly can be described as a data point with characteristics diverging from the data considered normal. For the use case of this project, we can make the assumption that our sensor readings follow a Gaussian distribution, as sensor readings normally do. To train the model a dataset with thousand sensor readings for temperature, humidity, and volume was generated. So we have a thousand data points for temperature with a mean of 25\u00b0 Celsius and a standard deviation of 5\u00b0 Celsius. For humidity, we have a thousand readings with 60% as the mean and 5% percent as the standard deviation. And finally, we have a thousand readings for volume with a mean of 100 decibels and a standard deviation of 10 decibels.<\/p>\n<h2>Model Selection<\/h2>\n<p>For the actual machine learning model, I decided to choose an isolation forest. The isolation forest algorithm is an unsupervised method for anomaly detection and is based on the principle that anomalies are rare and have characteristics that distinguish them from normal data points. The algorithm basically produces an ensemble of binary trees with anomalies resulting in short path lengths on the trees.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-256\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_model_selection-1.jpg\" alt=\"\" width=\"300\" height=\"214\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_model_selection-1.jpg 488w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_model_selection-1-300x214.jpg 300w\" sizes=\"(max-width: 300px) 100vw, 300px\" \/><\/p>\n<p>For every new data point that we want to predict, the model returns an anomaly score and a category. Thereby negative anomaly scores indicate an anomaly and positive anomaly scores predict a normal value. Given that the isolation forest is an eager learner with a very fast classification speed, it is ideal for the streaming data prediction of this project.<\/p>\n<h3>Training the Model<\/h3>\n<p>For this project, I used the implementation provided by the Scikit-learn library. It is important to note that the isolation forest needs a predefined level of expected anomalies. So all hyperparameters were left on their default values, except the expected anomaly percentage which was set to 5%. This value corresponds to the actual amount of flawed workpieces in the real production environment. Training the model and predicting the labels for the training dataset yielded the following graph with the blue points representing predicted anomalies.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-258\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_training.png\" alt=\"\" width=\"329\" height=\"306\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_training.png 329w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_training-300x279.png 300w\" sizes=\"(max-width: 329px) 100vw, 329px\" \/><\/p>\n<p>The model was then serialized so that it could be used later on.<\/p>\n<h2>Web App Overview<\/h2>\n<p>The web application really consists of two distinct components which are packaged into two separate apps inside a Django project. First, we have the API which handles incoming data and returns predictions. And as the second component, there is the administration interface which allows for registering machines and examination of logged parts. Let\u2019s start with a detailed view of the API.<\/p>\n<h3>Prediction API<\/h3>\n<p>So, the endpoint of the API which handles incoming sensor readings is based on a Django-Rest-Framework API View. The endpoint\u2019s functionality consists of four consecutive steps. First, we have a check if the request is from an authorized machine. If the received token and the machine&#8217;s description match a registered machine the next step is to create a new part.<\/p>\n<p>After the creation, the logging of the sensor values and the predictions happens. Additionally, the prediction is returned in JSON format. The last step is to finish the part by making it available in the administration interface. All these individual steps are triggered by an additional value that is contained in the request of the machining script.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-260\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_prediction_api.png\" alt=\"\" width=\"441\" height=\"371\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_prediction_api.png 441w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_prediction_api-300x252.png 300w\" sizes=\"(max-width: 441px) 100vw, 441px\" \/><\/p>\n<h3>Administration Interface<\/h3>\n<p>To complement the API, the application features an administration interface. The interface allows for registering machines and viewing the logged parts. To use the interface, logging in to the admin account is required.<\/p>\n<h4><strong>Machine Registration<\/strong><\/h4>\n<p>To register machines, we must first navigate to the Machines page where we can enter a machine description into the registration form. The authentication token is then automatically generated by the application. After registration, the machine description and the token must be copied and inserted into the machining script. Of course, it is also possible to register more than one machine.<\/p>\n<h4>Part Inspection<\/h4>\n<p>The second part of the administration interface is the part overview which can be reached by entering the Parts page. Early in the development of the application, the decision was made to split the continuous sensor measurement into segments that correspond to the machining of a single part. So, in other words, each machine has three sensors with the sensor readings linked to a specific part. A part is thereby a random number of sensor values.<\/p>\n<p>The anomaly score of the part is the cumulative score of all individual negative anomaly scores of the sensor readings. Additionally, parts have a start time and an end time. Additionally, the logged sensor values can be downloaded in CSV format.<\/p>\n<h3>Machine Simulation<\/h3>\n<p>The machine simulation is really a class that generates a random number of sensor readings and transmits them to the API via consecutive POST requests. To use the machining script, an instance of the machine class must be initiated. Here the registered machine name and token must be passed to the constructor of the class.<\/p>\n<p>In the second step, the part machining can be simulated by calling the process method of the new machine instance and passing the new parts name as a parameter. After executing the script, a random number of sensor readings is generated. I decided to sort the sensor readings before sending them so that the anomalies are centered around a specific section of a part and not randomly placed inside the data. I did this by labeling the anomalies, sorting them, and then removing the labels before sending them. In theory, this would happen automatically in the real environment.<\/p>\n<h2>Demonstration<\/h2>\n<p>So now let&#8217;s look into the final part of the report which is a small demonstration of how to use the whole system.<\/p>\n<h3>Login<\/h3>\n<p>The first step is to log in and register a new machine. For this, we boot up the local Django server, enter the address of the application inside a browser and enter the credentials.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-264 size-full\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-login.png\" alt=\"\" width=\"1044\" height=\"398\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-login.png 1044w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-login-300x114.png 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-login-1024x390.png 1024w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-login-768x293.png 768w\" sizes=\"(max-width: 1044px) 100vw, 1044px\" \/><\/p>\n<p>&nbsp;<\/p>\n<h3>Machine Registration<\/h3>\n<p>After successful login, we land on the homepage. Here are two smaller texts with instructions on how to use the application. We start by registering a new machine. For this, we click the Machines button which leads to the machines page. Here we type milling_01 into the registration form and click create machine. Now the new machine and the generated authentication token are displayed under the form.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-267\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-registration.png\" alt=\"\" width=\"1041\" height=\"404\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-registration.png 1041w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-registration-300x116.png 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-registration-1024x397.png 1024w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-registration-768x298.png 768w\" sizes=\"(max-width: 1041px) 100vw, 1041px\" \/><\/p>\n<h3><\/h3>\n<h3>Set Up the Simulation Script<\/h3>\n<p>Before we can start simulating a part, the machining script must be modified. We initialize a new machine with the registered name, enter the authentication token, and call the process method of the machine with the part&#8217;s name as an argument.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-268\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-init-machine.png\" alt=\"\" width=\"648\" height=\"121\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-init-machine.png 648w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-init-machine-300x56.png 300w\" sizes=\"(max-width: 648px) 100vw, 648px\" \/><\/p>\n<h3>Simulating a Part<\/h3>\n<p>The data generation is then started by executing the Python script. The simulated part can take from one to 5 minutes. If everything worked correctly our first returned value is a confirmation that a new part has been created. Following are the real-time predictions of the sensor measurements and lastly a message that the part has been finished. It is important to note that the application supports multiple machines running simultaneously.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter wp-image-271\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-simulation.jpg\" alt=\"\" width=\"800\" height=\"255\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-simulation.jpg 1172w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-simulation-300x95.jpg 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-simulation-1024x326.jpg 1024w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-simulation-768x244.jpg 768w\" sizes=\"(max-width: 800px) 100vw, 800px\" \/><\/p>\n<h3>Part Inspection<\/h3>\n<p>A finished part can be inspected by clicking the Part button on the homepage. Here we have an overview of the most important parameters like the anomaly score and you can also download the sensor values or delete the part. In the production environment, the anomaly score would now be used to have an educated guess about the quality of a single part.<\/p>\n<p><img loading=\"lazy\" decoding=\"async\" class=\"aligncenter size-full wp-image-273\" src=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-inspection.png\" alt=\"\" width=\"1041\" height=\"249\" srcset=\"http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-inspection.png 1041w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-inspection-300x72.png 300w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-inspection-1024x245.png 1024w, http:\/\/192.168.178.139\/wp-content\/uploads\/2023\/07\/anomaly-detection_demo-inspection-768x184.png 768w\" sizes=\"(max-width: 1041px) 100vw, 1041px\" \/><\/p>\n<h2>Conclusion<\/h2>\n<p>Moving forward, the system will be further refined and optimized based on the feedback and insights gained during the actual production with real sensor readings. Continuous monitoring, evaluation, and improvement will be essential to maximize the system&#8217;s performance and adaptability. As always the code and instructions on how to use the project are available on <a href=\"https:\/\/github.com\/marco507\/Factory-Anomaly-Detection\">GitHub<\/a>.<\/p>\n<style>#sp-ea-303 .spcollapsing { height: 0; overflow: hidden; transition-property: height;transition-duration: 300ms;}#sp-ea-303.sp-easy-accordion>.sp-ea-single {border: 1px solid #e2e2e2; }#sp-ea-303.sp-easy-accordion>.sp-ea-single>.ea-header a {color: #444;}#sp-ea-303.sp-easy-accordion>.sp-ea-single>.sp-collapse>.ea-body {background: #fff; color: #444;}#sp-ea-303.sp-easy-accordion>.sp-ea-single {background: #eee;}#sp-ea-303.sp-easy-accordion>.sp-ea-single>.ea-header a .ea-expand-icon.fa { float: left; color: #444;font-size: 16px;}<\/style><div id=\"sp_easy_accordion-1688997745\"><div id=\"sp-ea-303\" class=\"sp-ea-one sp-easy-accordion\" data-ex-icon=\"fa-minus\" data-col-icon=\"fa-plus\"  data-ea-active=\"ea-click\"  data-ea-mode=\"vertical\" data-preloader=\"\" data-scroll-active-item=\"\" data-offset-to-scroll=\"0\"><div class=\"ea-card  sp-ea-single\"><h3 class=\"ea-header\"><a class=\"collapsed\" data-sptoggle=\"spcollapse\" data-sptarget=#collapse3030 href=\"javascript:void(0)\"  aria-expanded=\"false\"><i class=\"ea-expand-icon fa fa-plus\"><\/i> References<\/a><\/h3><div class=\"sp-collapse spcollapse spcollapse\" id=\"collapse3030\" data-parent=#sp-ea-303><div class=\"ea-body\"><p>Liu, Fei Tony; Ting, Kai Ming; Zhou, Zhi Hua: Isolation Forest. In: Eighth IEEE International Conference on Data Mining 2008, S. 413 422.<\/p>\n<p>Ul Islam, Raihan; Hossain, Mohammad Shahadat; Andersson, Karl (2018): A novel anomaly detection algorithm for sensor data under uncertainty. In: Soft Computing 22 (5), S. 1623 1639<\/p>\n<\/div><\/div><\/div><\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>While working at my current workplace, the opportunity arose to design a proof-of-concept for a system that effectively identifies potential anomalies within the production cycle. [&#8230;]<\/p>\n","protected":false},"author":2,"featured_media":524,"comment_status":"closed","ping_status":"open","sticky":false,"template":"","format":"standard","meta":{"footnotes":""},"categories":[7,1],"tags":[],"_links":{"self":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/238"}],"collection":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/users\/2"}],"replies":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/comments?post=238"}],"version-history":[{"count":10,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/238\/revisions"}],"predecessor-version":[{"id":304,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/posts\/238\/revisions\/304"}],"wp:featuredmedia":[{"embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media\/524"}],"wp:attachment":[{"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/media?parent=238"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/categories?post=238"},{"taxonomy":"post_tag","embeddable":true,"href":"http:\/\/192.168.178.139\/wp-json\/wp\/v2\/tags?post=238"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}